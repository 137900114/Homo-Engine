DynamicDescriptorHeap

/*enum{
		DESCRIPTOR_HEAP_SIZE = 1024,
		DESCRIPTOR_TABLE_MAX_NUM = 32,
		MAX_HANDLE_PER_CACHE = 512
	};
	
	struct DescriptorHandle {
		CD3DX12_CPU_DESCRIPTOR_HANDLE cpuHandle;
		CD3DX12_GPU_DESCRIPTOR_HANDLE gpuHandle;

		DescriptorHandle(
			D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle,
			D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle
		) :cpuHandle(cpuHandle), gpuHandle(gpuHandle)
		{}

		DescriptorHandle& Offset(UINT num,UINT offset) {
			cpuHandle.Offset(num, offset);
			gpuHandle.Offset(num, offset);
		}
	};

	class DescriptorHeapAllocator {
	public:
		DescriptorHeapAllocator(D3D12_DESCRIPTOR_HEAP_TYPE Type):
		m_Type(Type){}

		void ReleaseUsedHeaps(size_t Fence,std::vector<ID3D12DescriptorHeap*>& toRelease);

		ID3D12DescriptorHeap* AllocateDescriptorHeap();

	private:
		ID3D12DescriptorHeap* CreateDescriptorHeap();

		std::vector<ComPtr<ID3D12DescriptorHeap>>			 m_DescriptorHeaps;
		std::queue<ID3D12DescriptorHeap*>					 m_AvaliableDescriptorHeaps;
		std::queue<std::pair<size_t, ID3D12DescriptorHeap*>> m_UsedDescriptorHeaps;
		D3D12_DESCRIPTOR_HEAP_TYPE m_Type;
	};

	class DynamicDescriptorHeap {

		struct DescriptorTableCache {
			DescriptorTableCache(D3D12_CPU_DESCRIPTOR_HANDLE* CpuHandle = nullptr, size_t TableSize = 0):
			m_CpuHandleStart(CpuHandle),
			m_BindedHandleBitMap(0),
			m_TableSize(TableSize)
			{ }

			D3D12_CPU_DESCRIPTOR_HANDLE* m_CpuHandleStart;
			size_t m_TableSize;
			uint32_t m_BindedHandleBitMap;
		};

		struct DescriptorHandleCache {

			DescriptorHandleCache() {
				ZeroMemory(m_CpuHandleCache, sizeof(m_CpuHandleCache));
				m_BindedTableBitMap = 0;
				m_VaildBindedTableBitMap = 0;
			}

			DescriptorTableCache m_TableCaches[DESCRIPTOR_TABLE_MAX_NUM];
			D3D12_CPU_DESCRIPTOR_HANDLE m_CpuHandleCache[MAX_HANDLE_PER_CACHE];

			uint32_t m_BindedTableBitMap;
			uint32_t m_VaildBindedTableBitMap;

			//将临时descriptor handle上传到cache暂存
			void UploadDescriptorHeaps(size_t RootIndex,size_t Offset,size_t Size,
				D3D12_CPU_DESCRIPTOR_HANDLE toUpload[]);

			void BindHandlesOnCache(ID3D12GraphicsCommandList* cmdList,
				void (ID3D12GraphicsCommandList::*SetFunc)(UINT,D3D12_GPU_DESCRIPTOR_HANDLE),
				DescriptorHandle pos);

			void ParseRootSignature(RootSignature* rootSignature);

			void UnBindAllHandles();

			size_t  ComputeNeededSize();
		};

	public:
		void BindAndSetComputeDescriptorHeap(ID3D12GraphicsCommandList* cmdList) {
			if (!m_ComputeHandleCache.m_VaildBindedTableBitMap)
				BindAndSetOnDescriptorHeap(m_ComputeHandleCache, cmdList, ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable);
		}

		void BindAndSetGraphicDescriptorHeap(ID3D12GraphicsCommandList* cmdList) {
			if(!m_GraphicHandleCache.m_VaildBindedTableBitMap)
				BindAndSetOnDescriptorHeap(m_GraphicHandleCache, cmdList, ID3D12GraphicsCommandList::SetComputeRootDescriptorTable);
		}

		void UploadDescriptorHandleGraphic(size_t RootIndex,size_t Offset,size_t Size,D3D12_CPU_DESCRIPTOR_HANDLE toUpload[]) {
			m_GraphicHandleCache.UploadDescriptorHeaps(RootIndex, Offset, Size, toUpload);
		}

		void UploadDescriptorHandleCompute(size_t RootIndex,size_t Offset,size_t Size,D3D12_CPU_DESCRIPTOR_HANDLE toUpload[]) {
			m_ComputeHandleCache.UploadDescriptorHeaps(RootIndex,Offset,Size,toUpload);
		}

		//在将handle绑定到Descriptor Heap上之前需要为其预留位置在DescriptorHeap上
		void ReserveSpaceForRootOnComputeHeap(RootSignature* rootSig) {
			m_ComputeHandleCache.ParseRootSignature(rootSig);
		}

		void ReserveSpaceForRootOnGraphicHeap(RootSignature* rootSig) {
			m_GraphicHandleCache.ParseRootSignature(rootSig);
		}

		//需要经常Release
		void ReleaseAll(UINT FenceVal) {
			DescriptorAllocators[m_Type].ReleaseUsedHeaps(FenceVal, m_RetiredHeaps);
		}

		ID3D12DescriptorHeap* GetHeap() { return m_CurrentHeap; }

	private:
		//调用函数之前必须先检查是否超出堆的范围
		DescriptorHandle AllocateHandle(size_t Size);

		bool HasSpace(size_t HandleNum) { return (m_CurrentHeap != nullptr && DESCRIPTOR_HEAP_SIZE >= (HandleNum + m_CurrentOffset) ) ; }

		void  BindAndSetOnDescriptorHeap(DescriptorHandleCache& Cache,
			ID3D12GraphicsCommandList* cmdList,
			void (ID3D12GraphicsCommandList::*SetFunc)(UINT,D3D12_GPU_DESCRIPTOR_HANDLE));

		void RetireCurrentHeap();

		ID3D12DescriptorHeap* AllocateFromDescriptorAllocator() {
			return DescriptorAllocators[m_Type].AllocateDescriptorHeap();
		}

		static DescriptorHeapAllocator DescriptorAllocators[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES];

		ID3D12DescriptorHeap* m_CurrentHeap = nullptr;

		uint32_t m_CurrentOffset;

		D3D12_DESCRIPTOR_HEAP_TYPE m_Type;
		
		std::vector<ID3D12DescriptorHeap*> m_RetiredHeaps;
		DescriptorHandleCache m_GraphicHandleCache;
		DescriptorHandleCache m_ComputeHandleCache;
	};
*/

/*DescriptorHeapAllocator DynamicDescriptorHeap::DescriptorAllocators[] = {
	DescriptorHeapAllocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV),
	DescriptorHeapAllocator(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER),
	DescriptorHeapAllocator(D3D12_DESCRIPTOR_HEAP_TYPE_RTV),
	DescriptorHeapAllocator(D3D12_DESCRIPTOR_HEAP_TYPE_DSV)
};

ID3D12DescriptorHeap* DescriptorHeapAllocator::CreateDescriptorHeap() {
	D3D12_DESCRIPTOR_HEAP_DESC desc;
	desc.NumDescriptors = DESCRIPTOR_HEAP_SIZE;
	desc.Type = m_Type;
	desc.NodeMask = 1;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

	ID3D12DescriptorHeap* res;
	ASSERT_HR(Device::GetCurrentDevice()->CreateDescriptorHeap(&desc,IID_PPV_ARGS(&res)),
		"DescriptorHeapAllocator : Failed to create new descriptor heap");
	return res;
}

ID3D12DescriptorHeap* DescriptorHeapAllocator::AllocateDescriptorHeap() {
	if (!m_AvaliableDescriptorHeaps.empty()) {
		ID3D12DescriptorHeap* heap = m_AvaliableDescriptorHeaps.front();
		m_AvaliableDescriptorHeaps.pop();
		return heap;
	}

	ComPtr<ID3D12DescriptorHeap> newHeap = CreateDescriptorHeap();
	m_DescriptorHeaps.push_back(newHeap);
	return newHeap.Get();
}

void DescriptorHeapAllocator::ReleaseUsedHeaps(
	size_t FenceVal,std::vector<ID3D12DescriptorHeap*>& toRelease) {
	while (!m_UsedDescriptorHeaps.empty() && Device::FenceIsCompleted(m_UsedDescriptorHeaps.front().first)) {
		ID3D12DescriptorHeap* newHeap = m_UsedDescriptorHeaps.front().second;
		m_UsedDescriptorHeaps.pop();
		m_AvaliableDescriptorHeaps.push(newHeap);
	}

	for (auto heap : toRelease) 
		m_UsedDescriptorHeaps.push(make_pair(FenceVal,heap));
}

size_t DynamicDescriptorHeap::DescriptorHandleCache::ComputeNeededSize() {
	if (m_BindedTableBitMap == 0) return 0;

	uint32_t bitMap = m_VaildBindedTableBitMap;
	UINT result = 0;
	UINT index = 0;
	while (_BitScanForward((DWORD*)&index,bitMap)) {
		bitMap ^= 1 << index;
		UINT heighestBindedBit;
		uint32_t assignedBitMap = m_TableCaches[index].m_BindedHandleBitMap;
		ASSERT_WARNING(!_BitScanReverse((DWORD*)&heighestBindedBit,assignedBitMap),
			"DescriptorHandleCache::ComputeNeededSize : there is no handle binded on a root parameter");

		result += heighestBindedBit;
	}
	return result;
}

void DynamicDescriptorHeap::DescriptorHandleCache::ParseRootSignature(RootSignature* rootSig) {
	ASSERT_WARNING(rootSig->RootIsCreated,"ParseRootSignature : the root signature has not been initialized");

	uint32_t m_DescriptorTableBitMap = rootSig->m_DescriptorTableBitMap;
	UINT index = 0;
	D3D12_CPU_DESCRIPTOR_HANDLE* currentHandle = m_CpuHandleCache;

	m_BindedTableBitMap = 0;

	while (_BitScanForward((DWORD*)&index,m_DescriptorTableBitMap)) {
		m_BindedTableBitMap |= 1 << index;
		m_DescriptorTableBitMap ^= 1 << index;

		size_t currentSize = rootSig->m_DescriptorTableSize[index];
		DescriptorTableCache& cache = m_TableCaches[index];
		cache.m_BindedHandleBitMap = 0;
		cache.m_CpuHandleStart = currentHandle;
		cache.m_TableSize = currentSize;

		currentHandle += currentSize;
	}

}

void DynamicDescriptorHeap::DescriptorHandleCache::UploadDescriptorHeaps(size_t RootIndex, size_t Offset, size_t Size,D3D12_CPU_DESCRIPTOR_HANDLE toUpload[]) {
	DescriptorTableCache& cache = m_TableCaches[RootIndex];
	
	ASSERT_WARNING(cache.m_TableSize < Offset + Size,"DescriptorHandleCache:the handle to upload is out off the range the cache reserved");
	memcpy(cache.m_CpuHandleStart + Offset,toUpload,sizeof(D3D12_CPU_DESCRIPTOR_HANDLE) * Size);

	cache.m_BindedHandleBitMap |= (1 << Size - 1) << Offset;
	m_VaildBindedTableBitMap |= 1 << RootIndex;
}

DescriptorHandle DynamicDescriptorHeap::AllocateHandle(size_t Size) {
	ASSERT_WARNING(!HasSpace(Size) , "DynamicDescriptorHeap : the handle allocate is out of the size");

	UINT offset = Device::GetDescriptorIncreamentHandleOffset(m_Type);
	D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle = m_CurrentHeap->GetGPUDescriptorHandleForHeapStart();
	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = m_CurrentHeap->GetCPUDescriptorHandleForHeapStart();
	DescriptorHandle res = DescriptorHandle(cpuHandle,gpuHandle).Offset(m_CurrentOffset,offset);

	m_CurrentOffset += Size;
	return res;
}

void DynamicDescriptorHeap::RetireCurrentHeap() {
	if (m_CurrentHeap != nullptr)
		m_RetiredHeaps.push_back(m_CurrentHeap);

	m_CurrentHeap = AllocateFromDescriptorAllocator();
	m_CurrentOffset = 0;

}

void DynamicDescriptorHeap::BindAndSetOnDescriptorHeap(DescriptorHandleCache& Cache,
	ID3D12GraphicsCommandList* cmdList,
	void (ID3D12GraphicsCommandList::* SetFunc)(UINT, D3D12_GPU_DESCRIPTOR_HANDLE)) {

	size_t CacheSize = Cache.ComputeNeededSize();

	ASSERT_WARNING(CacheSize > DESCRIPTOR_HEAP_SIZE,"there are too many descriptors on the heap");

	if (!HasSpace(CacheSize))
		RetireCurrentHeap();


	
}

void DynamicDescriptorHeap::DescriptorHandleCache::UnBindAllHandles() {
	uint32_t bitMap = m_BindedTableBitMap;

}*/


/*#pragma once


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "common.h"

#define HR_FAILED(hr,msg) if(FAILED(hr)) {MessageBox(NULL,msg,L"",MB_OK); return;}
#define HR_FAILED_RETURN(hr,msg,val) if(FAILED(hr)) {MessageBox(NULL,msg,L"",MB_OK); return val;}
#define HR_FAILED_EXP(hr,exp) if(FAILED(hr)) {exp;}

using namespace DirectX;

struct Vert {
	XMFLOAT3 pos;
	XMFLOAT4 Color;
};

struct CBuffer {
	XMFLOAT4X4 world;
	XMFLOAT4X4 proj;
};


HWND hwnd = NULL;

LPCTSTR WindowName = L"BzTutsApp";
LPCTSTR WindowTitle = L"Bz Window";
int Width = 800;
int Height = 600;
bool FullScreen = false;
bool Running = true;

bool InitializeWindow(HINSTANCE hInstance,
	int ShowWnd,
	bool fullscreen);


void mainloop();


LRESULT CALLBACK WndProc(HWND hWnd,
	UINT msg,
	WPARAM wParam,
	LPARAM lParam);

const int frameBufferCount = 3;
ComPtr<ID3D12Device> device;
ComPtr<IDXGISwapChain3> swapChain; 

ComPtr<ID3D12DescriptorHeap> rtvDescriptorHeap;
ComPtr<ID3D12DescriptorHeap> dsvDescriptorHeap;
ComPtr<ID3D12Resource> renderTargets[frameBufferCount];
ComPtr<ID3D12Resource> dsvBuffer;
const DXGI_FORMAT dsvFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
const DXGI_FORMAT rtvFormat = DXGI_FORMAT_R8G8B8A8_UNORM;
int rtvDescriptorSize;

ComPtr<ID3D12CommandAllocator> commandAllocator[frameBufferCount];
ComPtr<ID3D12GraphicsCommandList> commandList; 
ComPtr<ID3D12CommandQueue> commandQueue;
int frameIndex;

ComPtr<ID3D12Fence> fence[frameBufferCount];
HANDLE fenceEvent; 
UINT64 fenceValue[frameBufferCount];  


ComPtr<ID3D12Resource> boxGeoV;
ComPtr<ID3D12Resource> uploadGeoV;
UINT boxVSize;
ComPtr<ID3D12Resource> boxGeoI;
ComPtr<ID3D12Resource> uploadGeoI;
UINT boxISize;

ComPtr<ID3D12Resource> cbData;
void* cbMap;

ComPtr<ID3DBlob> VS;
ComPtr<ID3DBlob> PS;
ComPtr<ID3D12RootSignature> rootSig;
ComPtr<ID3D12PipelineState> pso;

std::vector<D3D12_INPUT_ELEMENT_DESC> layout;

#ifndef PI
#define PI 3.14159
#endif


float phi = 0.0f;
float theta = PI / 2.;
float radius = 4.f;

//--------------

bool UploadData();

bool CreateRootSigAndPSO();

bool InitD3D(); 

void Update();

void UpdatePipeline(); 

void Render(); 

void WaitForPreviousFrame();
//-------------------------

using namespace DirectX;

int WINAPI WinMain(HINSTANCE hInstance,   
	HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,
	int nShowCmd)
{
	ComPtr<ID3D12Debug> p;
	D3D12GetDebugInterface(IID_PPV_ARGS(&p));
	p->EnableDebugLayer();
	

	// create the window
	if (!InitializeWindow(hInstance, nShowCmd, FullScreen))
	{
		MessageBox(0, L"Window Initialization - Failed",
			L"Error", MB_OK);
		return 1;
	}

	if (!InitD3D())
	{
		MessageBox(0, L"Failed to initialize direct3d 12",
			L"Error", MB_OK);
		return 1;
	}

	commandAllocator[frameIndex].Get()->Reset();
	commandList->Reset(commandAllocator[frameIndex].Get(), nullptr);
	
	if ( !UploadData() || !CreateRootSigAndPSO()) {
		return -1;
	}

	commandList->Close();

	ID3D12CommandList* toExcute[] = {commandList.Get()};
	commandQueue->ExecuteCommandLists(_countof(toExcute), toExcute);
	
	WaitForPreviousFrame();

	XMMATRIX proj = XMMatrixPerspectiveFovLH(.25 * PI, Width / Height, 1., 1000.);
	XMFLOAT4X4* cbProj = &reinterpret_cast<CBuffer*>(cbMap)->proj;
	XMStoreFloat4x4(cbProj,proj);

	mainloop();


	WaitForPreviousFrame();

	cbData->Unmap(0,nullptr);

	CloseHandle(fenceEvent);

	return 0;
}

bool InitializeWindow(HINSTANCE hInstance,
	int ShowWnd,
	bool fullscreen)
{
	if (fullscreen)
	{
		HMONITOR hmon = MonitorFromWindow(hwnd,
			MONITOR_DEFAULTTONEAREST);
		MONITORINFO mi = { sizeof(mi) };
		GetMonitorInfo(hmon, &mi);

		Width = mi.rcMonitor.right - mi.rcMonitor.left;
		Height = mi.rcMonitor.bottom - mi.rcMonitor.top;
	}

	WNDCLASSEX wc;

	wc.cbSize = sizeof(WNDCLASSEX);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = WndProc;
	wc.cbClsExtra = NULL;
	wc.cbWndExtra = NULL;
	wc.hInstance = hInstance;
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 2);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = WindowName;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	if (!RegisterClassEx(&wc))
	{
		MessageBox(NULL, L"Error registering class",
			L"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	hwnd = CreateWindowEx(NULL,
		WindowName,
		WindowTitle,
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT,
		Width, Height,
		NULL,
		NULL,
		hInstance,
		NULL);

	if (!hwnd)
	{
		MessageBox(NULL, L"Error creating window",
			L"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	if (fullscreen)
	{
		SetWindowLong(hwnd, GWL_STYLE, 0);
	}

	ShowWindow(hwnd, ShowWnd);
	UpdateWindow(hwnd);

	return true;
}

void mainloop() {
	MSG msg;
	ZeroMemory(&msg, sizeof(MSG));

	while (Running)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			if (msg.message == WM_QUIT)
				break;

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else {

			Update(); 
			Render(); 
		}
	}
}

LRESULT CALLBACK WndProc(HWND hwnd,
	UINT msg,
	WPARAM wParam,
	LPARAM lParam)
{
	switch (msg)
	{
	case WM_KEYDOWN:
		if (wParam == VK_ESCAPE) {
			if (MessageBox(0, L"Are you sure you want to exit?",
				L"Really?", MB_YESNO | MB_ICONQUESTION) == IDYES)
			{
				Running = false;
				DestroyWindow(hwnd);
			}
		}
		return 0;

	case WM_DESTROY:
		Running = false;
		PostQuitMessage(0);
		return 0;
	}
	return DefWindowProc(hwnd,
		msg,
		wParam,
		lParam);
}

bool InitD3D()
{
	
	IDXGIFactory4* dxgiFactory;
	HR_FAILED_RETURN(CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)),L"创建factory失败",false);

	IDXGIAdapter1* adapter; 
	int adapterIndex = 0; 

	bool adapterFound = false; 
	
	HRESULT hr;
	while (dxgiFactory->EnumAdapters1(adapterIndex, &adapter) != DXGI_ERROR_NOT_FOUND)
	{
		DXGI_ADAPTER_DESC1 desc;
		adapter->GetDesc1(&desc);

		if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
		{
			adapterIndex++;
			continue;
		}

		hr = D3D12CreateDevice(adapter, D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), nullptr);
		if (SUCCEEDED(hr))
		{
			adapterFound = true;
			break;
		}

		adapterIndex++;
	}

	if (!adapterFound)
	{
		return false;
	}

	HR_FAILED_RETURN(D3D12CreateDevice(
		adapter,
		D3D_FEATURE_LEVEL_11_0,
		IID_PPV_ARGS(&device)
	),L"创建Device失败",false)


	D3D12_COMMAND_QUEUE_DESC cqDesc = {};
	cqDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	cqDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT; 

	HR_FAILED_RETURN(device->CreateCommandQueue(&cqDesc, IID_PPV_ARGS(&commandQueue)),L"创建command queue失败",false);



	DXGI_MODE_DESC backBufferDesc = {}; 
	backBufferDesc.Width = Width; 
	backBufferDesc.Height = Height; 
	backBufferDesc.Format = rtvFormat; 
	backBufferDesc.RefreshRate = { 60,1 };

	DXGI_SAMPLE_DESC sampleDesc = {};
	sampleDesc.Count = 1; 

	DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
	swapChainDesc.BufferCount = frameBufferCount; 
	swapChainDesc.BufferDesc = backBufferDesc; 
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; 
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; 
	swapChainDesc.OutputWindow = hwnd; 
	swapChainDesc.SampleDesc = sampleDesc; 
	swapChainDesc.Windowed = !FullScreen; 

	IDXGISwapChain* tempSwapChain;

	dxgiFactory->CreateSwapChain(
		commandQueue.Get(), 
		&swapChainDesc, 
		&tempSwapChain 
	);

	swapChain = static_cast<IDXGISwapChain3*>(tempSwapChain);

	frameIndex = swapChain->GetCurrentBackBufferIndex();

	

	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
	rtvHeapDesc.NumDescriptors = frameBufferCount; 
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;

	D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc = {};
	dsvHeapDesc.NumDescriptors = 1;
	dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	
	device->CreateDescriptorHeap(&rtvHeapDesc,IID_PPV_ARGS(rtvDescriptorHeap.GetAddressOf()));
	device->CreateDescriptorHeap(&dsvHeapDesc,IID_PPV_ARGS(dsvDescriptorHeap.GetAddressOf()));
	
	rtvDescriptorSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);


	D3D12_RESOURCE_DESC dsvDesc;
	dsvDesc.Alignment = 0;
	dsvDesc.DepthOrArraySize = 1;
	dsvDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	dsvDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
	dsvDesc.Format = dsvFormat;
	dsvDesc.Height = Height;
	dsvDesc.Width = Width;
	dsvDesc.MipLevels = 1;
	dsvDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
	dsvDesc.SampleDesc.Count = 1;
	dsvDesc.SampleDesc.Quality = 0;

	D3D12_CLEAR_VALUE val = {};
	val.Format = dsvFormat;
	val.DepthStencil.Depth = 1.f;
	val.DepthStencil.Stencil = 0;

	HR_FAILED_RETURN(device->CreateCommittedResource(
		&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
		D3D12_HEAP_FLAG_NONE,
		&dsvDesc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&val,
		IID_PPV_ARGS(&dsvBuffer)
		),L"创建dsvBuffer失败",false);
	
	device->CreateDepthStencilView(
	dsvBuffer.Get(),nullptr,dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart()
	);

	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

	for (int i = 0; i < frameBufferCount; i++)
	{
		HR_FAILED_RETURN(swapChain->GetBuffer(i, IID_PPV_ARGS(&renderTargets[i])),
			L"从swap chain取得render target失败",false);

		device->CreateRenderTargetView(renderTargets[i].Get(), nullptr, rtvHandle);

		rtvHandle.Offset(1, rtvDescriptorSize);
	}

	for (int i = 0; i < frameBufferCount; i++)
	{
		HR_FAILED_RETURN(device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator[i])),
			L"创建command allocator失败",false);

	}

	HR_FAILED_RETURN(device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator[0].Get(), NULL, IID_PPV_ARGS(&commandList)),
		L"创建command list失败", false);

	commandList->Close();

	for (int i = 0; i < frameBufferCount; i++)
	{
		HR_FAILED_RETURN(device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence[i])),
			L"创建fence失败",false)

		fenceValue[i] = 0; 
	}

	fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
	if (fenceEvent == nullptr)
	{
		return false;
	}

	return true;
}

inline XMVECTOR PackVector(float x,float y,float z,float w) {
	return XMLoadFloat4(&XMFLOAT4(x,y,z,w));
}

void Update()
{
	float x = cos(theta) * cos(phi) * radius;
	float y = sin(theta) * radius;
	float z = cos(theta) * sin(phi) * radius;

	XMVECTOR eyePos = XMVectorSet(x, y, z, 0.);
	XMVECTOR focus = XMVectorSet(0.,0.,0.,0.);
	XMVECTOR up = XMVectorSet(0.,1.,0.,0.);
	XMMATRIX mat = XMMatrixLookAtLH(eyePos,focus,up);

	XMFLOAT4X4* cbWorld = &reinterpret_cast<CBuffer*>(cbMap)->world;
	XMStoreFloat4x4(cbWorld,mat);
}

void UpdatePipeline()
{
	HRESULT hr;

	HR_FAILED_EXP(commandAllocator[frameIndex]->Reset(),Running = false);
	HR_FAILED_EXP(commandList->Reset(commandAllocator[frameIndex].Get(), NULL),Running = false);


	commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex].Get(), 
		D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart(), frameIndex, rtvDescriptorSize);
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart();

	commandList->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);

	const float clearColor[] = { 0.0f , 0.f, 0.f, 1.0f };
	commandList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    commandList->ClearDepthStencilView(dsvHandle,D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL,
		1.,0, 0,nullptr);

	commandList->SetPipelineState(pso.Get());
	commandList->SetGraphicsRootSignature(rootSig.Get());

	commandList->SetGraphicsRootConstantBufferView(0, cbData->GetGPUVirtualAddress());

	D3D12_VERTEX_BUFFER_VIEW vbv;
	vbv.BufferLocation = boxGeoV->GetGPUVirtualAddress();
	vbv.SizeInBytes = boxVSize;
	vbv.StrideInBytes = sizeof(Vert);

	commandList->IASetVertexBuffers(0, 1, &vbv);

	D3D12_INDEX_BUFFER_VIEW ibv;
	ibv.BufferLocation = boxGeoI->GetGPUVirtualAddress();
	ibv.Format = DXGI_FORMAT_R16_UINT;
	ibv.SizeInBytes = boxISize;

	commandList->IASetIndexBuffer(&ibv);

	commandList->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	
	commandList->DrawIndexedInstanced(36,1, 0 , 0, 0
	);

	commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex].Get(), 
		D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

	HR_FAILED_EXP(commandList->Close(), Running = false);
}

void Render()
{
	HRESULT hr;

	UpdatePipeline();

	ID3D12CommandList* ppCommandLists[] = { commandList.Get() };

	commandQueue->ExecuteCommandLists(_countof(ppCommandLists), ppCommandLists);

	HR_FAILED_EXP(swapChain->Present(0, 0),Running = false);

	WaitForPreviousFrame();
}


void WaitForPreviousFrame()
{

	fenceValue[frameIndex]++;
	
	HR_FAILED_EXP(commandQueue->Signal(fence[frameIndex].Get(), fenceValue[frameIndex]) , Running = false);

	frameIndex = swapChain->GetCurrentBackBufferIndex();
	if (fence[frameIndex]->GetCompletedValue() < fenceValue[frameIndex]) {
		HR_FAILED_EXP(fence[frameIndex]->SetEventOnCompletion(fenceValue[frameIndex],fenceEvent),Running = false);
		WaitForSingleObject(fenceEvent, INFINITE);
	}

}

ID3D12Resource* UploadResource(ID3D12Resource** upload,UINT size,void* data) {
	device->CreateCommittedResource(
		&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
		D3D12_HEAP_FLAG_NONE,
		&CD3DX12_RESOURCE_DESC::Buffer(size),
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,IID_PPV_ARGS(upload));

	void* mapData;
	(*upload)->Map(0, nullptr, &mapData);

	memcpy(mapData, data, size);

	ID3D12Resource* target;

	device->CreateCommittedResource(
		&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
		D3D12_HEAP_FLAG_NONE,
		&CD3DX12_RESOURCE_DESC::Buffer(size),
		D3D12_RESOURCE_STATE_COMMON,
		nullptr,IID_PPV_ARGS(&target));

	commandList->ResourceBarrier(1,
		&CD3DX12_RESOURCE_BARRIER::Transition(
			target,D3D12_RESOURCE_STATE_COMMON,D3D12_RESOURCE_STATE_COPY_DEST
		));

	commandList->CopyResource(target, *upload);

	commandList->ResourceBarrier(1,
		&CD3DX12_RESOURCE_BARRIER::Transition(
			target,D3D12_RESOURCE_STATE_COPY_DEST,D3D12_RESOURCE_STATE_COMMON
		));

	(*upload)->Unmap(0,nullptr);

	return target;
}


bool UploadData() {

	Vert data[] = {
		{{ 1., 1., 1.},{0.,0.,0.,1.}},
		{{ 1., 1.,-1.},{0.,0.,0.,1.}},
		{{ 1.,-1.,-1.},{0.,0.,0.,1.}},
		{{ 1.,-1., 1.},{0.,0.,0.,1.}},
		{{-1.,-1., 1.},{1.,1.,1.,1.}},
		{{-1.,-1.,-1.},{1.,1.,1.,1.}},
		{{-1., 1.,-1.},{1.,1.,1.,1.}},
		{{-1., 1., 1.},{1.,1.,1.,1.}}
	};

	uint16_t index[] = {
		0,1,2,
		0,2,3,
		0,3,4,
		0,4,7,
		4,3,2,
		4,2,5,
		1,0,6,
		6,0,7,
		1,6,2,
		2,6,5,
		4,5,6,
		4,6,7
	};

	boxGeoV = UploadResource(&uploadGeoV,sizeof(data),data);
	boxGeoI = UploadResource(&uploadGeoI,sizeof(index),index);

	boxVSize = sizeof(data);
	boxISize = sizeof(index);

	UINT cbSize = (sizeof(CBuffer) + 255) & ~255;

	device->CreateCommittedResource(
		&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
		D3D12_HEAP_FLAG_NONE,
		&CD3DX12_RESOURCE_DESC::Buffer(cbSize),
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr, IID_PPV_ARGS(&cbData)
	);

	cbData->Map(0, nullptr, &cbMap);

	return true;
}

bool CreateRootSigAndPSO() {
	layout = {
		{"POSITION",0,DXGI_FORMAT_R32G32B32_FLOAT,0,0,D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0},
		{"TEXCOORD",0,DXGI_FORMAT_R32G32B32A32_FLOAT,0,12,D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0}
	};

	CD3DX12_ROOT_PARAMETER params[1] = {};
	params[0].InitAsConstantBufferView(0);

	D3D12_ROOT_SIGNATURE_DESC rootSigDesc;
	rootSigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSigDesc.NumParameters = _countof(params);
	rootSigDesc.pParameters = params;
	rootSigDesc.NumStaticSamplers = 0;
	rootSigDesc.pStaticSamplers = nullptr;

	ComPtr<ID3DBlob> byte, error;
	D3D12SerializeRootSignature(
		&rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &byte, &error
	);

	if (error != nullptr) {
		MessageBoxA(NULL, (char*)error->GetBufferPointer(), "create root signature", MB_OK);
		return false;
	}

	HR_FAILED_RETURN(device->CreateRootSignature(0, byte->GetBufferPointer(), byte->GetBufferSize(), IID_PPV_ARGS(&rootSig)),
		L"创建 root signature失败" ,false);

	error = nullptr;
	D3DCompileFromFile(L"Shader\\Exp1\\box.hlsl", nullptr, nullptr,
		"VS", "vs_5_0", D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
		0, VS.GetAddressOf(), error.GetAddressOf());
	if (error != nullptr) {
		MessageBoxA(NULL, (char*)error->GetBufferPointer(), "compiling shader error", MB_OK);
		return false;
	}
	D3DCompileFromFile(L"Shader\\Exp1\\box.hlsl", nullptr, nullptr,
		"PS", "ps_5_0", D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
		0, PS.GetAddressOf(), error.GetAddressOf());
	if (error != nullptr) {
		MessageBoxA(NULL, (char*)error->GetBufferPointer(), "compiling shader error", MB_OK);
		return false;
	}


	D3D12_GRAPHICS_PIPELINE_STATE_DESC Pso;
	ZeroMemory(&Pso, sizeof(D3D12_GRAPHICS_PIPELINE_STATE_DESC));
	Pso.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
	Pso.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	Pso.PS = {
		PS->GetBufferPointer(),
		PS->GetBufferSize()
	};
	Pso.VS = {
		VS->GetBufferPointer(),
		VS->GetBufferSize()
	};
	Pso.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	Pso.DSVFormat = dsvFormat;
	Pso.InputLayout = { layout.data(),(UINT)layout.size() };
	Pso.NumRenderTargets = 1;
	Pso.RTVFormats[0] = rtvFormat;
	Pso.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	Pso.pRootSignature = rootSig.Get();
	Pso.SampleMask = UINT_MAX;
	Pso.SampleDesc.Count = 1;
	Pso.SampleDesc.Quality = 0;

	HR_FAILED_RETURN(device->CreateGraphicsPipelineState(
		&Pso, IID_PPV_ARGS(&pso)
	),L"创建 pso 失败" ,false);


	return true;
}*/
